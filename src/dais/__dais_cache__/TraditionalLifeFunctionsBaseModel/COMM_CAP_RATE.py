
#THIS CODE IS AUTO-GENERATED by timeloop_tempate, DO NOT DIRECTLY EDIT UNLESS YOU KNOW WHAT YOU ARE DOING!

from numba import njit, void, prange
import numpy as np
import math
from numpy import float64, int32, int64

@njit(nogil=True, cache=True)
def COMM_CAP_RATE(POL_YR,CP_TYPE_patch,COMM_ID,COMM_LIMIT_TYPE_derived,BASE_COMM_CAP_RATE,COMM_CAP_AG_FAC,COMM_LIMIT_ADJ):
	if COMM_LIMIT_TYPE_derived==999999:
		return 999999
	else:
		if (((POL_YR==1) and ((CP_TYPE_patch==0) or (CP_TYPE_patch==1))) or (CP_TYPE_patch==2)) and COMM_ID<=5:
			# return round(BASE_COMM_CAP_RATE * COMM_CAP_AG_FAC * COMM_LIMIT_ADJ,1)
			return math.floor(BASE_COMM_CAP_RATE * COMM_CAP_AG_FAC * COMM_LIMIT_ADJ*10)/10
		else:
			return BASE_COMM_CAP_RATE * COMM_CAP_AG_FAC * COMM_LIMIT_ADJ


@njit(nogil=True, parallel=True, cache=True)
def wrapped_COMM_CAP_RATE(POL_YR,CP_TYPE_patch,COMM_ID,COMM_LIMIT_TYPE_derived,BASE_COMM_CAP_RATE,COMM_CAP_AG_FAC,COMM_LIMIT_ADJ):
	arr_COMM_CAP_RATE=np.zeros(POL_YR.shape,dtype=float64)
	for y in prange(POL_YR.shape[0]):
		for t in range(POL_YR.shape[1]):
			arr_COMM_CAP_RATE[y,t]=COMM_CAP_RATE(POL_YR[y,t],CP_TYPE_patch[y,0],COMM_ID[y,0],COMM_LIMIT_TYPE_derived[y,0],BASE_COMM_CAP_RATE[y,t],COMM_CAP_AG_FAC[y,t],COMM_LIMIT_ADJ[y,0])
	return arr_COMM_CAP_RATE
