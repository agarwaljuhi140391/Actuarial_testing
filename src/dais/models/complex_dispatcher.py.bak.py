import numpy as np
import inspect
import binascii
import importlib
import os
import dais
from numpy import int32, int64, float64
from numba import prange,njit

class CompiledFunction:
	timeloop_template="""
#THIS CODE IS AUTO-GENERATED by timeloop_tempate, DO NOT DIRECTLY EDIT UNLESS YOU KNOW WHAT YOU ARE DOING!

from numba import njit, void, prange
import numpy as np
from numpy import float64, int32, int64

@njit(nogil=True, cache=True)
{funcstring}

@njit(nogil=True, parallel=True, cache=True)
def wrapped_{funcname}({vars}):
	arr_{funcname}=np.zeros({sizing_var}.shape,dtype={dtype})
	for y in prange({sizing_var}.shape[0]):
		for t in range({sizing_var}.shape[1]):
			arr_{funcname}[y,t]={funcname}({args})
	return arr_{funcname}
"""
	simple_template="""
#THIS CODE IS AUTO-GENERATED by simple_template, DO NOT DIRECTLY EDIT UNLESS YOU KNOW WHAT YOU ARE DOING!

from numba import njit, void, prange
import numpy as np
from numpy import float64, int32, int64

@njit(nogil=True, cache=True)
{funcstring}

@njit(nogil=True, parallel=True, cache=True)
def wrapped_{funcname}({vars}):
	arr_{funcname}=np.zeros(({sizing_var}.shape[0],1),dtype={dtype})
	for y in prange({sizing_var}.shape[0]):
		arr_{funcname}[y,0]={funcname}({args})
	return arr_{funcname}
"""
	complex_template="""
#THIS CODE IS AUTO-GENERATED by complex_template, DO NOT DIRECTLY EDIT UNLESS YOU KNOW WHAT YOU ARE DOING!

from numba import njit, void, prange
import numpy as np
from numpy import float64, int32, int64
from ..models.simple_dispatcher import irr_est

@njit(nogil=True, parallel=True, cache=True)
{funcstring}

def wrapped_{funcname}({reduced_vars}):
	arr_{funcname}=np.zeros(({shape}),dtype={dtype})
	{funcname}({reduced_vars},arr_{funcname})
	return arr_{funcname}
"""
	derivedcomplex_template="""
#THIS CODE IS AUTO-GENERATED by derivedcomplex_template, DO NOT DIRECTLY EDIT UNLESS YOU KNOW WHAT YOU ARE DOING!

from numba import njit, void, prange
import numpy as np
from numpy import float64, int32, int64

@njit(nogil=True, parallel=True, cache=True)
{funcstring}

def wrapped_{funcname}({reduced_vars}):
	{array_creation}
	{funcname}({reduced_vars},{created_arrs})
	return {dict_of_arrays}
"""

	permitted_types=set(['Derived','DerivedComplex','DerivedBond'])

	def __init__(self,funcnode,argnodes,cachepath=None):
		assert funcnode.source_type in self.permitted_types
		self.funcnode=funcnode
		self.argnodes=argnodes
		if cachepath:
			assert os.path.isdir(cachepath)
			self.cachepath=cachepath
		else:
			self.cachepath = os.path.normpath(os.path.join(inspect.getfile(dais),'..','__dais_cache__'))
		assembledfile=self.assembleFileContents()
		self.cache_hit=self.compare(assembledfile,self.readCacheContent())
		if not self.cache_hit:
			print('Caching: ',self.funcnode.name)
			self.write_cache(assembledfile)
			print('Initialising: ',self.funcnode.name)
			self.initialise_cache()
		mod=importlib.import_module('dais.__dais_cache__.'+funcnode.name)
		importlib.reload(mod)
		self.numba_func=getattr(mod,'wrapped_'+self.funcnode.name)
		
	def write_cache(self,assembledfile):
		with open(os.path.join(self.cachepath,self.funcnode.name+'.py'),'wb') as f:
			f.write(assembledfile)
		
	def initialise_cache(self):
		mod=importlib.import_module('dais.__dais_cache__.'+self.funcnode.name)
		importlib.reload(mod)
		numba_func=getattr(mod,'wrapped_'+self.funcnode.name)
		args=[]
		for arg in self.argnodes:
			args.append(np.zeros((3,3),dtype=arg.attr['type']))
			# if arg.name=='T':
				# args[-1].setflags(write=False)
		testrun=numba_func(*args)
		# print(self.funcnode.name,numba_func.signatures)
	
	def compare(self,a,b):
		crc_a=binascii.crc32(a)
		crc_b=binascii.crc32(b)
		if crc_a==crc_b:
			return True
		else:
			return False
		
	def readCacheContent(self):
		try:
			with open(os.path.join(self.cachepath,self.funcnode.name+'.py'),'rb') as f:
				cachecontent=f.read()
			return cachecontent
		except (NameError,FileNotFoundError) as e:
			return b''
	
	def assembleFileContents(self):
		if self.funcnode.source_type=='DerivedBond':
			sizing_var_candidates=[argnode.name for argnode in self.argnodes if argnode.attr['shape']==self.funcnode.attr['shape']]
			if len(sizing_var_candidates)>0:
				sv=sizing_var_candidates[0]
				shape="{sv}.shape[0],np.max(MV_NUMPERIODS)".format(sv=sv)
			else:
				sv=[argnode.name for argnode in self.argnodes if argnode.attr['shape'] >0][0]
				shape="{sv}.shape[0],1".format(sv=sv)
			template_inputs={'funcname': self.funcnode.name
							,'dtype':np.dtype(self.funcnode.attr['type']).name
							,'funcstring':"".join([line[1:] for line in self.funcnode.get_func_string().splitlines(keepends=True)])
							,'reduced_vars':",".join([argnode.name for argnode in self.argnodes])
							,'shape':"{shape}".format(shape=shape)
							}
			filecontents=self.complex_template.format(**template_inputs)
		elif self.funcnode.source_type=='DerivedComplex':
			sizing_var_candidates=[argnode.name for argnode in self.argnodes if argnode.attr['shape']==2]
			sv=sizing_var_candidates[0]
			args_create=[]
			args_call=[]
			args_return=[]
			for arg in self.funcnode.attr['outvars'].keys():
				args_create.append("arr_{argname}=np.zeros({sizing_var}.shape,{dtype})".format(sizing_var=sv,argname=arg,dtype=self.funcnode.attr['outvars'][arg]['type']))
				args_call.append("arr_{argname}".format(argname=arg))
				args_return.append("'{argname}': arr_{argname}".format(argname=arg))
			template_inputs={'funcname': self.funcnode.name
							,'array_creation': "\n\t".join(args_create)
							,'funcstring':"".join([line[1:] for line in self.funcnode.get_func_string().splitlines(keepends=True)])
							,'reduced_vars':",".join([argnode.name for argnode in self.argnodes])
							,'created_arrs':",".join(args_call)
							,'dict_of_arrays':"{"+",".join(args_return)+"}"
			}
			filecontents=self.derivedcomplex_template.format(**template_inputs)
		elif self.funcnode.attr['numba']=='j':
			sizing_var_candidates=[argnode.name for argnode in self.argnodes if argnode.attr['shape']==self.funcnode.attr['shape']]
			if len(sizing_var_candidates)>0:
				sv=sizing_var_candidates[0]
				shape="{sv}.shape[0],{sv}.shape[1]".format(sv=sv)
			else:
				sv=[argnode.name for argnode in self.argnodes if argnode.attr['shape'] >0][0]
				shape="{sv}.shape[0],1".format(sv=sv)
			template_inputs={'funcname': self.funcnode.name
							,'dtype':np.dtype(self.funcnode.attr['type']).name
							,'funcstring':"".join([line[1:] for line in self.funcnode.get_func_string().splitlines(keepends=True)])
							,'reduced_vars':",".join([argnode.name for argnode in self.argnodes])
							,'shape':"{shape}".format(shape=shape)
							}
			filecontents=self.complex_template.format(**template_inputs)
		elif self.funcnode.attr['numba']=='v':
			if self.funcnode.attr['shape']==2:
				args=[]
				for argnode in self.argnodes:
					print (argnode)
					if argnode.attr['shape']==2:
						args.append(argnode.name+'[y,t]')
					elif argnode.attr['shape']==0:
						args.append(argnode.name+'[0,0]')
					else:
						args.append(argnode.name+'[y,0]')
				template_inputs={'funcname': self.funcnode.name
								,'dtype':np.dtype(self.funcnode.attr['type']).name
								,'funcstring': "".join([line[1:] for line in self.funcnode.get_func_string().splitlines(keepends=True)])
								,'vars': ",".join([argnode.name for argnode in self.argnodes])
								,'args': ",".join(args)
								,'sizing_var': [argnode.name for argnode in self.argnodes if argnode.attr['shape']==2][0]}
				filecontents=self.timeloop_template.format(**template_inputs)
			else:
				args=[]
				for argnode in self.argnodes:
					assert argnode.attr['shape'] != 2
					if argnode.attr['shape']==1:
						args.append(argnode.name+'[y,0]')
					else:
						args.append(argnode.name+'[0,0]')
				template_inputs={'funcname': self.funcnode.name
								,'dtype':np.dtype(self.funcnode.attr['type']).name
								,'funcstring': "".join([line[1:] for line in self.funcnode.get_func_string().splitlines(keepends=True)])
								,'vars': ",".join([argnode.name for argnode in self.argnodes])
								,'args': ",".join(args)
								,'sizing_var': [argnode.name for argnode in self.argnodes if argnode.attr['shape']==1][0]}
				filecontents=self.simple_template.format(**template_inputs)
		return filecontents.encode('UTF-8')
