import numpy as np

import inspect
import binascii
import importlib
import os
from pathlib import Path
import dais
from numpy import int32, int64, float64
from numba import prange
from .complex_dispatcher import CompiledFunction

class CompiledFunctionRF(CompiledFunction):
	permitted_types=set(['Collapser','Derived','DerivedComplex','DerivedBond'])

	collapser_template="""
#THIS CODE IS AUTO-GENERATED by timeloop_tempate, DO NOT DIRECTLY EDIT UNLESS YOU KNOW WHAT YOU ARE DOING!

from numba import njit, void, prange
import numpy as np
import math
from numpy import float64, int32, int64

@njit(nogil=True, parallel=True, cache=True)
def wrapped_{funcname}({vars}):
	arr_{funcname}=np.zeros(({result_shape}),dtype={dtype})
{for_loops}
{execution_tabs}arr_{funcname}[{out_indexes}] = {args}.{collapse_function}()
	return arr_{funcname}

"""
	timeloopcollapser_template="""
#THIS CODE IS AUTO-GENERATED by timeloop_tempate, DO NOT DIRECTLY EDIT UNLESS YOU KNOW WHAT YOU ARE DOING!

from numba import njit, void, prange
import numpy as np
import math
from numpy import float64, int32, int64

@njit(nogil=True, parallel=True, cache=True)
def wrapped_{funcname}({vars},arr_{funcname}):
{for_loops}
{execution_tabs}arr_{funcname}[{out_indexes}] = {args}.{collapse_function}()
"""
	timeloopj_template="""
#THIS CODE IS AUTO-GENERATED by timeloop_tempate, DO NOT DIRECTLY EDIT UNLESS YOU KNOW WHAT YOU ARE DOING!

from numba import njit, void, prange
import numpy as np
import math
from numpy import float64, int32, int64

@njit(nogil=True, cache=True)
{funcstring}

@njit(nogil=True, parallel=True, cache=True)
def wrapped_{funcname}({vars},arr_{funcname}):
{for_loops}
{execution_tabs}{funcname}({args},arr_{funcname}[{out_indexes}])
"""
	timeloopv_template="""
#THIS CODE IS AUTO-GENERATED by timeloop_tempate, DO NOT DIRECTLY EDIT UNLESS YOU KNOW WHAT YOU ARE DOING!

from numba import njit, void, prange
import numpy as np
import math
from numpy import float64, int32, int64

@njit(nogil=True, cache=True)
{funcstring}

@njit(nogil=True, parallel=True, cache=True)
def wrapped_{funcname}({vars},arr_{funcname}):
{for_loops}
{execution_tabs}arr_{funcname}[{out_indexes}] = {funcname}({args})
"""
	timev_template="""
#THIS CODE IS AUTO-GENERATED by timeloop_tempate, DO NOT DIRECTLY EDIT UNLESS YOU KNOW WHAT YOU ARE DOING!

from numba import njit, void, prange
import numpy as np
import math
from numpy import float64, int32, int64

@njit(nogil=True, cache=True)
{funcstring}

@njit(nogil=True, parallel=True, cache=True)
def wrapped_{funcname}({vars}):
	arr_{funcname}=np.zeros(({result_shape}),dtype={dtype})
{for_loops}
{execution_tabs}arr_{funcname}[{out_indexes}] = {funcname}({args})
	return arr_{funcname}
"""

	timej_template="""
#THIS CODE IS AUTO-GENERATED by timeloop_tempate, DO NOT DIRECTLY EDIT UNLESS YOU KNOW WHAT YOU ARE DOING!

from numba import njit, void, prange
import numpy as np
import math
from numpy import float64, int32, int64

@njit(nogil=True, cache=True)
{funcstring}

@njit(nogil=True, parallel=True, cache=True)
def wrapped_{funcname}({vars}):
	arr_{funcname}=np.zeros(({result_shape}),dtype={dtype})
{for_loops}
{execution_tabs}{funcname}({args},arr_{funcname}[{out_indexes}])
	return arr_{funcname}
"""

	def __init__(self,funcnode,argnodes,classname,alignments=None,cachepath=None,debug=False):
		self.alignments=alignments
		self.executors=dict(CompiledFunction.executors)
		self.executors.update({
			'j':self._aFC_j
			,'v2':self._aFC_v2
			,'coll':self._aFC_coll
			,'loopcoll':self._aFC_loopcoll
			,'loopv':self._aFC_loopv
			,'loopj':self._aFC_loopj
		})
		super().__init__(funcnode,argnodes,classname,cachepath=None,debug=False)
		
	def assembleFileContents(self):
		if self.funcnode.is_loopvar():
			if self.funcnode.source_type=='Collapser':
				filecontents=self.executors['loopcoll']()
			elif self.funcnode.attr['numba']=='v':
				filecontents=self.executors['loopv']()
			elif self.funcnode.attr['numba']=='j':
				filecontents=self.executors['loopj']()
		else:
			if self.funcnode.source_type=='DerivedComplex':
				filecontents=self.executors['DerivedComplex']()
			elif self.funcnode.source_type=='Collapser':
				filecontents=self.executors['coll']()
			elif self.funcnode.attr['numba']=='j':
				filecontents=self.executors['j']()
			elif self.funcnode.attr['numba']=='v':
				if self.funcnode.attr['shape']==2:
					filecontents=self.executors['v2']()
				else:
					filecontents=self.executors['v1']()
		return filecontents.encode('UTF-8')

	def initialise_cache(self):
		mod=importlib.import_module(self.modulepath)
		importlib.reload(mod)
		numba_func=getattr(mod,'wrapped_'+self.funcnode.name)
		args=[]
		for arg in self.argnodes:
			shape=tuple([15 for align in self.alignments.keys()]+[15])
			args.append(np.zeros(shape,dtype=arg.attr['type']))
			# if arg.name=='T':
				# args[-1].setflags(write=False)
		if self.funcnode.is_loopvar():
			args.append(np.zeros(shape,dtype=self.funcnode.attr['type']))
		# print(self.funcnode.name,[arg.shape for arg in args])
		testrun=numba_func(*args)
		# print(self.funcnode.name,numba_func.signatures)

	def _aFC_loopj(self):
		print("In rf per aFC_loopj: ",self.funcnode.name)
		args=[]
		for argnode in self.argnodes:
			argindexes = [align.lower() if (align in argnode.attr['alignment']) else '0' for align in self.alignments.keys()]
			argindexes.append(':')
			args.append(argnode.name+'['+','.join(argindexes)+']')
		# sizing_var=[argnode.name for argnode in self.argnodes if argnode.attr['alignment']==self.funcnode.attr['alignment']][0]
		for_loops=[]
# 		result_shape=[]
		out_indexes=[]
		n=0
		start_tabs=1
		snippet="{tabs}for {alignment} in prange(arr_{funcname}.shape[{alignment_idx}]):"
		for i,key in enumerate(self.alignments.keys()):
			if key in self.funcnode.attr['alignment']:
# 				result_shape.append('{source}.shape[{i}]'.format(**{'source':sizing_var,'i':i}))
				out_indexes.append(key.lower())
				for_loops.append(snippet.format(**{'funcname':self.funcnode.name
													, 'tabs':'\t'*(start_tabs+n)
													, 'alignment':key.lower()
													, 'alignment_idx':i}))
				n+=1
			else:
				# result_shape.append('1')
				out_indexes.append('0')
		out_indexes.append(':')
		execution_tabs='\t'*(start_tabs+n)
# 		result_shape.append('{source}.shape[{i}]'.format(**{'source':	,'i':i+1}))
		template_inputs={'funcname': self.funcnode.name
				,'dtype':np.dtype(self.funcnode.attr['type']).name
				,'funcstring': "".join([line[1:] for line in self.funcnode.get_func_string().splitlines(keepends=True)])
				,'vars': ",".join([argnode.name for argnode in self.argnodes])
				,'args': ",".join(args)
				,'for_loops': "\n".join(for_loops)
# 				,'result_shape': ",".join(result_shape)
				, 'execution_tabs': execution_tabs
				, 'out_indexes': ",".join(out_indexes)}
		# print(template_inputs)
		return self.timeloopj_template.format(**template_inputs)
		

	def _aFC_loopv(self):
		# if self.debug:
		print("In rf pre aFC_loopv: ",self.funcnode.name)
		args=[]
# 		out_indexes=','.join([align.lower() if align in self.funcnode.attr['alignment'] else '0' for align in self.alignments])
		for argnode in self.argnodes:
			argindexes = [align.lower() if (align in argnode.attr['alignment']) else '0' for align in self.alignments.keys()]
			argindexes.append(':' if argnode.attr.get('monthly') else 't')
			args.append(argnode.name+'['+','.join(argindexes)+']')
		# print(args)
		sizing_var=[argnode.name for argnode in self.argnodes if argnode.attr['alignment']==self.funcnode.attr['alignment']][0]
		for_loops=[]
		result_shape=[]
		out_indexes=[]
		n=0
		start_tabs=1
		snippet="{tabs}for {alignment} in prange(arr_{funcname}.shape[{alignment_idx}]):"
		for i,key in enumerate(self.alignments.keys()):
			if key in self.funcnode.attr['alignment']:
				result_shape.append('{source}.shape[{i}]'.format(**{'source':sizing_var,'i':i}))
				out_indexes.append(key.lower())
				for_loops.append(snippet.format(**{'funcname':self.funcnode.name
													, 'tabs':'\t'*(start_tabs+n)
													, 'alignment':key.lower()
													, 'alignment_idx':i}))
				n+=1
			else:
				result_shape.append('1')
				out_indexes.append('0')
		for_loops.append(snippet.format(**{'funcname':self.funcnode.name
											, 'tabs':'\t'*(start_tabs+n)
											, 'alignment':'t'
											, 'alignment_idx':i+1}))
		out_indexes.append('t')
		execution_tabs='\t'*(start_tabs+n+1)
		result_shape.append('{source}.shape[{i}]'.format(**{'source':sizing_var,'i':i+1}))
	
		template_inputs={'funcname': self.funcnode.name
				,'dtype':np.dtype(self.funcnode.attr['type']).name
				,'funcstring': "".join([line[1:] for line in self.funcnode.get_func_string().splitlines(keepends=True)])
				,'vars': ",".join([argnode.name for argnode in self.argnodes])
				,'args': ",".join(args)
				,'for_loops': "\n".join(for_loops)
				,'result_shape': ",".join(result_shape)
				, 'execution_tabs': execution_tabs
				, 'out_indexes': ",".join(out_indexes)}
		# print(template_inputs)
		return self.timeloopv_template.format(**template_inputs)

	def _aFC_loopcoll(self):
		if self.debug:
			print("In rf pre aFC_coll: ",self.funcnode.name)
		for_loops=[]
		result_shape=[]
		in_indexes=[]
		out_indexes=[]
		n=0
		start_tabs=1
		snippet="{tabs}for {alignment} in prange(arr_{funcname}.shape[{alignment_idx}]):"
		for i,key in enumerate(self.alignments.keys()):
			if key in self.funcnode.attr['alignment']:
				for_loops.append(snippet.format(**{'funcname':self.funcnode.name
													, 'tabs':'\t'*(start_tabs+n)
													, 'alignment':key.lower()
													, 'alignment_idx':i}))
				result_shape.append('{source}.shape[{i}]'.format(**{'source':self.funcnode.attr['source'], 'i':i}))
				in_indexes.append(key.lower())
				out_indexes.append(key.lower())
				n+=1
			else:
				result_shape.append('1')
				in_indexes.append(':')
				out_indexes.append('0')
		result_shape.append('{source}.shape[{i}]'.format(**{'source':self.funcnode.attr['source'],'i':i+1}))
		in_indexes.append('t')
		out_indexes.append('t')
		for_loops.append(snippet.format(**{'funcname':self.funcnode.name
										  , 'tabs':'\t'*(start_tabs+n)
										  , 'alignment':'t'
										  , 'alignment_idx': i+1
										 }))
		
		execution_tabs='\t'*(start_tabs+n+1)

		template_inputs={'funcname': self.funcnode.name
						,'dtype':np.dtype(self.funcnode.attr['type']).name
						,'collapse_function': self.funcnode.attr['func']
						,'vars': self.funcnode.attr['source']
						,'args': '{arg}[{in_indexes}]'.format(**{'arg':self.funcnode.attr['source'],'in_indexes':','.join(in_indexes)})
						,'for_loops': "\n".join(for_loops)
						,'result_shape': ",".join(result_shape)
						, 'execution_tabs': execution_tabs
						, 'out_indexes': ",".join(out_indexes)}

		if self.debug:
			print(template_inputs)
		return self.timeloopcollapser_template.format(**template_inputs)


	def _aFC_coll(self):
		if self.debug:
			print("In rf pre aFC_coll: ",self.funcnode.name)
		for_loops=[]
		result_shape=[]
		in_indexes=[]
		out_indexes=[]
		n=0
		start_tabs=1
		snippet="{tabs}for {alignment} in prange(arr_{funcname}.shape[{alignment_idx}]):"
		for i,key in enumerate(self.alignments.keys()):
			if key in self.funcnode.attr['alignment']:
				for_loops.append(snippet.format(**{'funcname':self.funcnode.name
													, 'tabs':'\t'*(start_tabs+n)
													, 'alignment':key.lower()
													, 'alignment_idx':i}))
				result_shape.append('{source}.shape[{i}]'.format(**{'source':self.funcnode.attr['source'], 'i':i}))
				in_indexes.append(key.lower())
				out_indexes.append(key.lower())
				n+=1
			else:
				result_shape.append('1')
				in_indexes.append(':')
				out_indexes.append('0')
		result_shape.append('{source}.shape[{i}]'.format(**{'source':self.funcnode.attr['source'],'i':i+1}))
		in_indexes.append('t')
		out_indexes.append('t')
		for_loops.append(snippet.format(**{'funcname':self.funcnode.name
										  , 'tabs':'\t'*(start_tabs+n)
										  , 'alignment':'t'
										  , 'alignment_idx': i+1
										 }))
		
		execution_tabs='\t'*(start_tabs+n+1)

		template_inputs={'funcname': self.funcnode.name
						,'dtype':np.dtype(self.funcnode.attr['type']).name
						,'collapse_function': self.funcnode.attr['func']
						,'vars': self.funcnode.attr['source']
						,'args': '{arg}[{in_indexes}]'.format(**{'arg':self.funcnode.attr['source'],'in_indexes':','.join(in_indexes)})
						,'for_loops': "\n".join(for_loops)
						,'result_shape': ",".join(result_shape)
						, 'execution_tabs': execution_tabs
						, 'out_indexes': ",".join(out_indexes)}

		if self.debug:
			print(template_inputs)
		return self.collapser_template.format(**template_inputs)

	def _aFC_v2(self):
		if self.debug:
			print("In rf pre aFC_v2: ",self.funcnode.name)
		args=[]
		out_indexes=','.join([align.lower() if align in self.funcnode.attr['alignment'] else '0' for align in self.alignments])
		for argnode in self.argnodes:
			args.append(argnode.name+'['+','.join([align.lower() if align in argnode.attr['alignment'] else '0' for align in self.alignments]+['t'])+']') #added 't' to here

		sizing_var=[argnode.name for argnode in self.argnodes if argnode.attr['alignment']==self.funcnode.attr['alignment']][0]
		for_loops=[]
		result_shape=[]
		out_indexes=[]
		n=0
		start_tabs=1
		snippet="{tabs}for {alignment} in prange(arr_{funcname}.shape[{alignment_idx}]):"
		for i,key in enumerate(self.alignments.keys()):
			if key in self.funcnode.attr['alignment']:
				result_shape.append('{source}.shape[{i}]'.format(**{'source':sizing_var,'i':i}))
				out_indexes.append(key.lower())
				for_loops.append(snippet.format(**{'funcname':self.funcnode.name
													, 'tabs':'\t'*(start_tabs+n)
													, 'alignment':key.lower()
													, 'alignment_idx':i}))
				n+=1
			else:
				result_shape.append('1')
				out_indexes.append('0')
		for_loops.append(snippet.format(**{'funcname':self.funcnode.name
											, 'tabs':'\t'*(start_tabs+n)
											, 'alignment':'t'
											, 'alignment_idx':i+1}))
		out_indexes.append('t')
		execution_tabs='\t'*(start_tabs+n+1)
		result_shape.append('{source}.shape[{i}]'.format(**{'source':sizing_var,'i':i+1}))

		template_inputs={'funcname': self.funcnode.name
						,'dtype':np.dtype(self.funcnode.attr['type']).name
						,'funcstring': "".join([line[1:] for line in self.funcnode.get_func_string().splitlines(keepends=True)])
						,'vars': ",".join([argnode.name for argnode in self.argnodes])
						,'args': ",".join(args)
						,'for_loops': "\n".join(for_loops)
						,'result_shape': ",".join(result_shape)
						, 'execution_tabs': execution_tabs
						, 'out_indexes': ",".join(out_indexes)}
		if self.debug:
			print(template_inputs)
		return self.timev_template.format(**template_inputs)


	def _aFC_j(self):
		if self.debug:
			print("In rf pre aFC_j: ",self.funcnode.name)
		args=[]
		out_indexes=','.join([align.lower() if align in self.funcnode.attr['alignment'] else '0' for align in self.alignments])
		for argnode in self.argnodes:
			args.append(argnode.name+'['+','.join([align.lower() if align in argnode.attr['alignment'] else '0' for align in self.alignments])+']')

		sizing_var=[argnode.name for argnode in self.argnodes if argnode.attr['alignment']==self.funcnode.attr['alignment']][0]
		for_loops=[]
		result_shape=[]
		out_indexes=[]
		n=0
		start_tabs=1
		snippet="{tabs}for {alignment} in prange(arr_{funcname}.shape[{alignment_idx}]):"
		for i,key in enumerate(self.alignments.keys()):
			if key in self.funcnode.attr['alignment']:
				result_shape.append('{source}.shape[{i}]'.format(**{'source':sizing_var,'i':i}))
				out_indexes.append(key.lower())
				for_loops.append(snippet.format(**{'funcname':self.funcnode.name
													, 'tabs':'\t'*(start_tabs+n)
													, 'alignment':key.lower()
													, 'alignment_idx':i}))
				n+=1
			else:
				result_shape.append('1')
				out_indexes.append('0')
		execution_tabs='\t'*(start_tabs+n)
		result_shape.append('{source}.shape[{i}]'.format(**{'source':sizing_var,'i':i+1}))

		template_inputs={'funcname': self.funcnode.name
						,'dtype':np.dtype(self.funcnode.attr['type']).name
						,'funcstring': "".join([line[1:] for line in self.funcnode.get_func_string().splitlines(keepends=True)])
						,'vars': ",".join([argnode.name for argnode in self.argnodes])
						,'args': ",".join(args)
						,'for_loops': "\n".join(for_loops)
						,'result_shape': ",".join(result_shape)
						, 'execution_tabs': execution_tabs
						, 'out_indexes': ",".join(out_indexes)}
		if self.debug:
			print(template_inputs)
		return self.timej_template.format(**template_inputs)

